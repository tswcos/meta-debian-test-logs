bin
busybox
run-ptest
testsuite
======================
echo -ne '' >input
echo -ne '' | ./unknown 2>&1
PASS: busybox as unknown name
SKIP: busybox --help busybox
======================
echo -ne '' >input
echo -ne '' | busybox 2>&1 | cat
PASS: busybox
======================
echo -ne '' >input
echo -ne '' | busybox unknown 2>&1
PASS: busybox unknown
======================
echo -ne '' >input
echo -ne '' | busybox --help 2>&1
PASS: busybox --help
SKIP: busybox cat
SKIP: busybox --help cat
======================
echo -ne '' >input
echo -ne '' | busybox --help unknown 2>&1
PASS: busybox --help unknown
======================
echo -ne '' >input
echo -ne '' | ./busybox-suffix 2>&1 | cat
PASS: ./busybox-suffix
======================
echo -ne '' >input
echo -ne '' | ./busybox-suffix unknown 2>&1
PASS: ./busybox-suffix unknown
======================
echo -ne '' >input
echo -ne '' | ./busybox-suffix --help 2>&1
PASS: ./busybox-suffix --help
SKIP: ./busybox-suffix cat
SKIP: ./busybox-suffix --help cat
======================
echo -ne '' >input
echo -ne '' | ./busybox-suffix --help unknown 2>&1
PASS: ./busybox-suffix --help unknown
======================
echo -ne '' >input
echo -ne '' | awk -F '[#]' '{ print NF }'
PASS: awk -F case 0
======================
echo -ne '' >input
echo -ne '\n' | awk -F '[#]' '{ print NF }'
PASS: awk -F case 1
======================
echo -ne '' >input
echo -ne '#\n' | awk -F '[#]' '{ print NF }'
PASS: awk -F case 2
======================
echo -ne '' >input
echo -ne '#abc#\n' | awk -F '[#]' '{ print NF }'
PASS: awk -F case 3
======================
echo -ne '' >input
echo -ne '#abc#zz\n' | awk -F '[#]' '{ print NF }'
PASS: awk -F case 4
======================
echo -ne '' >input
echo -ne '#abc##zz\n' | awk -F '[#]' '{ print NF }'
PASS: awk -F case 5
======================
echo -ne '' >input
echo -ne 'z#abc##zz\n' | awk -F '[#]' '{ print NF }'
PASS: awk -F case 6
======================
echo -ne '' >input
echo -ne 'z##abc##zz\n' | awk -F '[#]' '{ print NF }'
PASS: awk -F case 7
======================
echo -ne '' >input
echo -ne '' | awk 'BEGIN{if(23==23) print "foo"}'
PASS: awk if operator == 
======================
echo -ne '' >input
echo -ne '' | awk 'BEGIN{if(23!=23) print "bar"}'
PASS: awk if operator != 
======================
echo -ne '' >input
echo -ne '' | awk 'BEGIN{if(23>=23) print "foo"}'
PASS: awk if operator >= 
======================
echo -ne '' >input
echo -ne '' | awk 'BEGIN{if(2 < 13) print "foo"}'
PASS: awk if operator < 
======================
echo -ne '' >input
echo -ne '' | awk 'BEGIN{if("a"=="ab") print "bar"}'
PASS: awk if string == 
======================
echo -ne '' >input
echo -ne '\n' | awk '{ print or(4294967295,1) }'
PASS: awk bitwise op
======================
echo -ne '' >input
echo -ne '' | awk '
function empty_fun(count) {
  # empty
}
END {
  i=1
  print "L" i "\n"
  empty_fun(i + i + ++i)
  print "L" i "\n"
}'
PASS: awk handles empty function f(arg){}
======================
echo -ne '' >input
echo -ne '' | awk '
function outer_fun() {
  return 1
}
END {
  i=1
  print "L" i "\n"
  i += outer_fun()
  print "L" i "\n"
}'
PASS: awk properly handles function from other scope
======================
echo -ne '' >input
echo -ne '' | awk '
END {
  i=1
  print "L" i "\n"
  i + trigger_error_fun()
  print "L" i "\n"
}' 2>&1
PASS: awk properly handles undefined function
SKIP: awk hex const 1
SKIP: awk hex const 2
SKIP: awk oct const
======================
echo -ne '' >input
echo -ne '\n' | awk '{ printf "%f %f\n", "000.123", "009.123" }'
PASS: awk floating const with leading zeroes
======================
echo -ne '' >input
echo -ne 'a--\na--b--\na--b--c--\na--b--c--d--' | awk -F-- '{ print NF, length($NF), $NF }'
PASS: awk long field sep
======================
echo -ne '' >input
echo -ne 'a!b\n' | awk -F'\x21' '{print $1}'
PASS: awk -F handles escapes
======================
echo -ne '' >input
echo -ne 'Hi\n' | awk 'gsub("@(samp|code|file)\{","");'; echo $?
PASS: awk gsub falls back to non-extended-regex
======================
echo -ne '' >input
echo -ne '' | awk -f awk_t1_opt-functions.awk -f awk_t1_opth-gen.awk <awk_t1_input | md5sum
PASS: awk 'gcc build bug'
======================
echo -ne '' >input
echo -ne '' | awk 'BEGIN { print ":" NF ":" $0 ":" $1 ":" $2 ":" }'
PASS: awk NF in BEGIN
======================
echo -ne '' >input
echo -ne '' | awk '
function b(tmp) {
	tmp = 0;
	print "" tmp; #this line causes the bug
	return tmp;
}
function c(tmpc) {
	tmpc = b(); return tmpc;
}
BEGIN {
	print (c() ? "string" : "number");
}'
PASS: awk string cast (bug 725)
======================
echo -ne '' >input
echo -ne '' | awk 'BEGIN { arr [3] = 1; print arr [3] }'
PASS: awk handles whitespace before array subscript
======================
echo -ne '' >input
echo -ne '' | awk 'BEGIN { getline line <"doesnt_exist"; print ERRNO; ERRNO=0; close("doesnt_exist"); print ERRNO; print "Ok" }'
PASS: awk handles non-existing file correctly
======================
echo -ne '' >input
echo -ne '' | awk '
BEGIN {
  u["a"]=1
  u["b"]=1
  u["c"]=1
  v["d"]=1
  v["e"]=1
  v["f"]=1
  for (l in u) {
    print "outer1", l;
    for (l in v) {
      print " inner", l;
    }
    print "outer2", l;
  }
  print "end", l;
  l="a"
  exit;
}'
PASS: awk nested loops with the same variable
======================
echo -ne '' >input
echo -ne '' | awk '
BEGIN{
cnt = 0
a[cnt] = "zeroth"
a[++cnt] = "first"
delete a[cnt--]
print cnt
print "[0]:" a[0]
print "[1]:" a[1]
}'
PASS: awk 'delete a[v--]' evaluates v-- once
======================
echo -ne '' >input
echo -ne '' | awk 'BEGIN {print()}' 2>&1
PASS: awk handles empty ()
======================
echo -ne '' >input
echo -ne 'a:b c:d\ne:f g:h' | awk '{FS=":"; print $1}'
PASS: awk FS assignment
======================
echo -ne '' >input
echo -ne '' | awk 'BEGIN{n=(2^31)-1; print n, int(n), n%1, ++n, int(n), n%1}'
PASS: awk large integer
======================
echo -ne '' >input
echo -ne '' | awk 'BEGIN{ A[1]=2; A["qwe"]="asd"; print length(A)}'
PASS: awk length(array)
======================
echo -ne '' >input
echo -ne 'qwe' | awk '{print length; print length(); print length("qwe"); print length(99+9)}'
PASS: awk length()
======================
echo -ne 'do re mi\n' >input
echo -ne '{print $2; print ARGC;}' | awk -f - input
PASS: awk -f and ARGC
======================
echo -ne 'do re mi\n' >input
echo -ne '' | awk -e '{print $2; print ARGC;}' input
PASS: awk -e and ARGC
======================
echo -ne '' >input
echo -ne 'BEGIN { if (1) break; else a = 1 }' | awk -f - 2>&1; echo $?
PASS: awk break
======================
echo -ne '' >input
echo -ne 'BEGIN { if (1) continue; else a = 1 }' | awk -f - 2>&1; echo $?
PASS: awk continue
======================
echo -ne '' >input
echo -ne '' | awk '{ for() }' 2>&1
PASS: awk handles invalid for loop
======================
echo -ne '' >input
echo -ne 'anything' | awk 2>&1 -- '{ $(-1) }'
PASS: awk negative field access
PASS: basename-does-not-remove-identical-extension
PASS: basename-works
PASS: bunzip2-reads-from-standard-input
PASS: bunzip2-removes-compressed-file
PASS: bunzip2: doesnt exist
PASS: bunzip2: unknown suffix
PASS: bunzip2: already exists
PASS: bunzip2: stream unpack
PASS: bunzip2: delete src
PASS: bunzip2: test_bz2 file
PASS: bunzip2: pbzip_4m_zeros file
PASS: bunzip2: bz2_issue_11.bz2 corrupted example
PASS: bunzip2: bz2_issue_12.bz2 corrupted example
PASS: bzcat-does-not-remove-compressed-file
PASS: zcat: dont delete gz src
PASS: zcat: dont delete bz2 src
PASS: zcat: dont delete Z src
======================
echo -ne '\x42\x5a\x68\x39\x31\x41\x59\x26\x53\x59\x63\x3e\xd6\xe2\x00\x00\x00\xc1\x00\x00\x10\x20\x00\x20\x00\x21\x00\x82\xb1\x77\x24\x53\x85\x09\x06\x33\xed\x6e\x20' >input
echo -ne '' | bzcat input input; echo $?
PASS: bzcat can print many files
======================
echo -ne '\x42\x5a\x68\x39\x17\x72\x45\x38\x50\x90\x00\x00\x00\x00' >input
echo -ne '' | bzcat input input; echo $?
PASS: bzcat can handle compressed zero-length bzip2 files
======================
echo -ne '\x1f\x9d\x90\x61\x14\x00' >input
echo -ne '' | zcat input input; echo $?
PASS: zcat can print many files
======================
echo -ne '\x1f\x9d\x90\x00' >input
echo -ne '' | zcat input input; echo $?
PASS: zcat can handle compressed zero-length (.Z) files
PASS: cat-prints-a-file
PASS: cat-prints-a-file-and-standard-input
SKIP: cat -e
SKIP: cat -v
PASS: cmp-detects-difference
PASS: cp-RHL-does_not_preserve-links
PASS: cp-a-files-to-dir
PASS: cp-a-preserves-links
PASS: cp-copies-empty-file
PASS: cp-copies-large-file
PASS: cp-copies-small-file
PASS: cp-d-files-to-dir
PASS: cp-dev-file
PASS: cp-dir-create-dir
PASS: cp-dir-existing-dir
PASS: cp-does-not-copy-unreadable-file
PASS: cp-files-to-dir
PASS: cp-follows-links
SKIP: cp-parents
SKIP: cp-preserves-hard-links
PASS: cp-preserves-links
PASS: cp-preserves-source-file
======================
echo -ne '' >input
echo -ne '' | \
cd cp.testdir || exit 1; cp * ../cp.testdir2 2>&1; echo $?; cd ../cp.testdir2 || exit 1
test ! -L file         && test   -f file             || echo BAD: file
test ! -L file_symlink && test   -f file_symlink     || echo BAD: file_symlink
test ! -L dir          && test ! -e dir              || echo BAD: dir
test ! -L dir_symlink  && test ! -e dir_symlink      || echo BAD: dir_symlink

PASS: cp
======================
echo -ne '' >input
echo -ne '' | \
cd cp.testdir || exit 1; cp -d * ../cp.testdir2 2>&1; echo $?; cd ../cp.testdir2 || exit 1
test ! -L file         && test   -f file             || echo BAD: file
test   -L file_symlink && test   -f file_symlink     || echo BAD: file_symlink
test ! -L dir          && test ! -e dir              || echo BAD: dir
test   -L dir_symlink  && test ! -e dir_symlink      || echo BAD: dir_symlink

PASS: cp -d
======================
echo -ne '' >input
echo -ne '' | \
cd cp.testdir || exit 1; cp -P * ../cp.testdir2 2>&1; echo $?; cd ../cp.testdir2 || exit 1
test ! -L file         && test   -f file             || echo BAD: file
test   -L file_symlink && test   -f file_symlink     || echo BAD: file_symlink
test ! -L dir          && test ! -e dir              || echo BAD: dir
test   -L dir_symlink  && test ! -e dir_symlink      || echo BAD: dir_symlink

PASS: cp -P
======================
echo -ne '' >input
echo -ne '' | \
cd cp.testdir || exit 1; cp -L * ../cp.testdir2 2>&1; echo $?; cd ../cp.testdir2 || exit 1
test ! -L file         && test   -f file             || echo BAD: file
test ! -L file_symlink && test   -f file_symlink     || echo BAD: file_symlink
test ! -L dir          && test ! -e dir              || echo BAD: dir
test ! -L dir_symlink  && test ! -e dir_symlink      || echo BAD: dir_symlink

PASS: cp -L
======================
echo -ne '' >input
echo -ne '' | \
cd cp.testdir || exit 1; cp -H * ../cp.testdir2 2>&1; echo $?; cd ../cp.testdir2 || exit 1
test ! -L file         && test   -f file             || echo BAD: file
test ! -L file_symlink && test   -f file_symlink     || echo BAD: file_symlink
test ! -L dir          && test ! -e dir              || echo BAD: dir
test ! -L dir_symlink  && test ! -e dir_symlink      || echo BAD: dir_symlink

PASS: cp -H
======================
echo -ne '' >input
echo -ne '' | \
cd cp.testdir || exit 1; cp -R * ../cp.testdir2 2>&1; echo $?; cd ../cp.testdir2 || exit 1
test ! -L file             && test   -f file             || echo BAD: file
test   -L file_symlink     && test   -f file_symlink     || echo BAD: file_symlink
test ! -L dir              && test   -d dir              || echo BAD: dir
test   -L dir_symlink      && test   -d dir_symlink      || echo BAD: dir_symlink
test ! -L dir/file         && test   -f dir/file         || echo BAD: dir/file
test   -L dir/file_symlink && test   -f dir/file_symlink || echo BAD: dir/file_symlink

PASS: cp -R
======================
echo -ne '' >input
echo -ne '' | \
cd cp.testdir || exit 1; cp -Rd * ../cp.testdir2 2>&1; echo $?; cd ../cp.testdir2 || exit 1
test ! -L file             && test   -f file             || echo BAD: file
test   -L file_symlink     && test   -f file_symlink     || echo BAD: file_symlink
test ! -L dir              && test   -d dir              || echo BAD: dir
test   -L dir_symlink      && test   -d dir_symlink      || echo BAD: dir_symlink
test ! -L dir/file         && test   -f dir/file         || echo BAD: dir/file
test   -L dir/file_symlink && test   -f dir/file_symlink || echo BAD: dir/file_symlink

PASS: cp -Rd
======================
echo -ne '' >input
echo -ne '' | \
cd cp.testdir || exit 1; cp -RP * ../cp.testdir2 2>&1; echo $?; cd ../cp.testdir2 || exit 1
test ! -L file             && test   -f file             || echo BAD: file
test   -L file_symlink     && test   -f file_symlink     || echo BAD: file_symlink
test ! -L dir              && test   -d dir              || echo BAD: dir
test   -L dir_symlink      && test   -d dir_symlink      || echo BAD: dir_symlink
test ! -L dir/file         && test   -f dir/file         || echo BAD: dir/file
test   -L dir/file_symlink && test   -f dir/file_symlink || echo BAD: dir/file_symlink

PASS: cp -RP
======================
echo -ne '' >input
echo -ne '' | \
cd cp.testdir || exit 1; cp -RL * ../cp.testdir2 2>&1; echo $?; cd ../cp.testdir2 || exit 1
test ! -L file             && test   -f file             || echo BAD: file
test ! -L file_symlink     && test   -f file_symlink     || echo BAD: file_symlink
test ! -L dir              && test   -d dir              || echo BAD: dir
test ! -L dir_symlink      && test   -d dir_symlink      || echo BAD: dir_symlink
test ! -L dir/file         && test   -f dir/file         || echo BAD: dir/file
test ! -L dir/file_symlink && test   -f dir/file_symlink || echo BAD: dir/file_symlink

PASS: cp -RL
======================
echo -ne '' >input
echo -ne '' | \
cd cp.testdir || exit 1; cp -RHL * ../cp.testdir2 2>&1; echo $?; cd ../cp.testdir2 || exit 1
test ! -L file             && test   -f file             || echo BAD: file
test ! -L file_symlink     && test   -f file_symlink     || echo BAD: file_symlink
test ! -L dir              && test   -d dir              || echo BAD: dir
test ! -L dir_symlink      && test   -d dir_symlink      || echo BAD: dir_symlink
test ! -L dir/file         && test   -f dir/file         || echo BAD: dir/file
test ! -L dir/file_symlink && test   -f dir/file_symlink || echo BAD: dir/file_symlink

PASS: cp -RHL
======================
echo -ne '' >input
echo -ne '' | echo -ne '\x42\x5a\x68\x39\x31\x41\x59\x26\x53\x59\x64\x1e\x91\x8c\x00\x00\x48\x7f\x80\x4c\x48\x08\x00\x28\x01\xff\xe0\x3f\x24\x14\x00\x0e\x20\xdc\x60\x20\x00\x92\x11\xea\xa0\x1a\x00\x00\x00\x03\x20\x8a\x93\xd4\x9a\x68\x1a\x0d\x1e\x91\xa1\xa0\x06\x98\xe3\x5c\x2f\xd9\x26\xa1\x25\x24\x20\xed\x47\xc7\x21\x40\x2b\x6e\xf2\xe6\xfe\x98\x13\x68\xa8\xbd\x82\xb2\x4f\x26\x02\x24\x16\x5b\x22\x16\x72\x74\x15\xcd\xc1\xa6\x9e\xa6\x5e\x6c\x16\x37\x35\x01\x99\xc4\x81\x21\x29\x28\x4b\x69\x51\xa9\x3c\x1a\x9b\x0a\xe1\xe4\xb4\xaf\x85\x73\xba\x23\x10\x59\xe8\xb3\xe1\xa1\x63\x05\x8c\x4f\xc5\xdc\x91\x4e\x14\x24\x19\x07\xa4\x63\x00' | bzcat | cpio -i 2>&1; echo $?;
ls -ln cpio.testdir | sed 's/  */ /g' | cut -d' ' -f 1-5,9- | grep -v '^total '
PASS: cpio extracts zero-sized hardlinks
SKIP: cpio extracts zero-sized hardlinks 2
SKIP: cpio -p with absolute paths
SKIP: cpio restores suid/sgid bits
======================
echo -ne '' >input
echo -ne '' | echo -ne '\x42\x5a\x68\x39\x31\x41\x59\x26\x53\x59\x64\x1e\x91\x8c\x00\x00\x48\x7f\x80\x4c\x48\x08\x00\x28\x01\xff\xe0\x3f\x24\x14\x00\x0e\x20\xdc\x60\x20\x00\x92\x11\xea\xa0\x1a\x00\x00\x00\x03\x20\x8a\x93\xd4\x9a\x68\x1a\x0d\x1e\x91\xa1\xa0\x06\x98\xe3\x5c\x2f\xd9\x26\xa1\x25\x24\x20\xed\x47\xc7\x21\x40\x2b\x6e\xf2\xe6\xfe\x98\x13\x68\xa8\xbd\x82\xb2\x4f\x26\x02\x24\x16\x5b\x22\x16\x72\x74\x15\xcd\xc1\xa6\x9e\xa6\x5e\x6c\x16\x37\x35\x01\x99\xc4\x81\x21\x29\x28\x4b\x69\x51\xa9\x3c\x1a\x9b\x0a\xe1\xe4\xb4\xaf\x85\x73\xba\x23\x10\x59\xe8\xb3\xe1\xa1\x63\x05\x8c\x4f\xc5\xdc\x91\x4e\x14\x24\x19\x07\xa4\x63\x00' | bzcat | cpio -id 2>&1; echo $?
PASS: cpio extracts in existing directory
SKIP: cpio uses by default uid/gid
SKIP: cpio -R with create
SKIP: cpio -R with extract
PASS: cut-cuts-a-character
PASS: cut-cuts-a-closed-range
PASS: cut-cuts-a-field
PASS: cut-cuts-an-open-range
PASS: cut-cuts-an-unclosed-range
======================
echo -ne 'the quick brown fox\n' >input
echo -ne 'jumps over the lazy dog\n' | cut -d' ' -f2 - input
PASS: cut '-' (stdin) and mdc: syntax error at '?2'
dc: syntax error at '?2'
ulti file handling
PASS: date-@-works
PASS: date-R-works
PASS: date-format-works
PASS: date-u-works
PASS: date-works
PASS: date-works-1
======================
echo -ne '' >input
echo -ne '10 20+p' | dc
PASS: dc basic syntax (stdin, multiple args)
======================
echo -ne '' >input
echo -ne '' | dc -e'10 20+p'
PASS: dc basic syntax (argv, single arg)
======================
echo -ne '' >input
echo -ne '' | dc -e10 -e20+p
PASS: dc basic syntax (argv, multiple args)
======================
echo -ne '' >input
echo -ne '' | dc -e'8 8 * 2 2 + / p'
PASS: dc complex with spaces (single arg)
======================
echo -ne '' >input
echo -ne '' | dc -e'8 8*2 2+/p'
PASS: dc complex without spaces (single arg)
======================
echo -ne '' >input
echo -ne '' | dc -e8 -e8 -e\* -e2 -e2 -e+ -e/ -ep
PASS: dc complex with spaces (multiple args)
======================
echo -ne '' >input
echo -ne '' | dc -e8 -e8\*2 -e2+/p
PASS: dc complex without spaces (multiple args)
======================
echo -ne '1?2\nf' >input
echo -ne '9\n' | dc -finput
FAIL: dc read
--- expected
+++ actual
@@ -1,3 +0,0 @@
-2
-9
-1
======================
echo -ne '1?2\nf' >input
echo -ne '[str]\n' | dc -finput
FAIL: dc read string
--- expected
+++ actual
@@ -1,3 +0,0 @@
-2
-str
-1
SKIP: dc '>a' (conditional execute string) 1
SKIP: dc '>a' (conditional execute string) 2
SKIP: dc '>aeb' (conditional execute string with else)
SKIP: dc space can be a register
SKIP: dc newline can be a register
SKIP: dc dc_add.dc
SKIP: dc dc_boolean.dc
SKIP: dc dc_decimal.dc
SKIP: dc dc_divide.dc
SKIP: dc dc_divmod.dc
SKIP: dc dc_misc.dc
SKIP: dc dc_modexp.dc
SKIP: dc dc_modulus.dc
SKIP: dc dc_multiply.dc
SKIP: dc dc_power.dc
SKIP: dc dc_sqrt.dc
SKIP: dc dc_strings.dc
SKIP: dc dc_subtract.dc
SKIP: dc -x dcx_vars.dc
PASS: dd-accepts-if
PASS: dd-accepts-of
PASS: dd-copies-from-standard-input-to-standard-output
PASS: dd-prints-count-to-standard-error
PASS: dd-reports-write-errors
======================
echo -ne 'qwe\nasd\nzxc\n' >input
echo -ne 'asd\n' | diff -u - input | sed 's/	.*//'
PASS: diff of stdin
======================
echo -ne 'qwe\nasd\nzxc' >input
echo -ne 'asd\n' | diff -u - input | sed 's/	.*//'
PASS: diff of stdin, no newline in the file
======================
echo -ne '' >input
echo -ne 'stdin' | diff - -; echo $?; wc -c
PASS: diff of stdin, twice
======================
echo -ne '' >input
echo -ne 'a\n' | diff -u - input | sed 's/	.*//'
PASS: diff of empty file against stdin
======================
echo -ne 'a\n' >input
echo -ne '' | diff -u - input | sed 's/	.*//'
PASS: diff of empty file against nonempty one
======================
echo -ne 'abc' >input
echo -ne 'abc ' | diff -ub - input; echo $?
PASS: diff -b treats EOF as whitespace
======================
echo -ne 'a \t c\n' >input
echo -ne 'a\t \tc\n' | diff -ub - input; echo $?
PASS: diff -b treats all spaces as equal
======================
echo -ne 'a\n' >input
echo -ne '\na\n\n' | diff -uB - input; echo $?
PASS: diff -B ignores changes whose lines are all blank
======================
echo -ne 'a\n' >input
echo -ne '\nb\n\n' | diff -uB - input | sed 's/	.*//'
PASS: diff -B does not ignore changes whose lines are not all blank
======================
echo -ne '\n1\n' >input
echo -ne '1\n' | diff -qB - input; echo $?
PASS: diff -B ignores blank single line change
======================
echo -ne '0\n' >input
echo -ne '1\n' | diff -qB - input; echo $?
PASS: diff -B does not ignore non-blank single line change
======================
echo -ne 'abc\na  c\ndef\n' >input
echo -ne 'a c\n' | diff -ub - input | sed 's/	.*//'
PASS: diff always takes context from old file
======================
echo -ne '' >input
echo -ne '' | diff -ur diff1 diff2/subdir | sed 's/	.*//'
PASS: diff diff1 diff2/subdir
======================
echo -ne '' >input
echo -ne '' | diff -ur diff1 diff2/subdir/- | sed 's/	.*//'
PASS: diff dir dir2/file/-
======================
echo -ne '' >input
echo -ne '' | diff -ur diff1 diff2/subdir | sed 's/	.*//'
PASS: diff of dir and fifo
======================
echo -ne '' >input
echo -ne '' | diff -ur diff1 diff2/subdir | sed 's/	.*//'
PASS: diff of file and fifo
======================
echo -ne '' >input
echo -ne '' | diff -urN diff1 diff2/subdir | sed 's/	.*//'
PASS: diff -rN does not read non-regular files
======================
echo -ne '' >input
echo -ne '' | diff -ur diff1 diff2/ | sed 's/	.*//'; diff -ur .///diff1 diff2//// | sed 's/	.*//'
PASS: diff diff1 diff2/
PASS: dirname-handles-absolute-path
PASS: dirname-handles-empty-path
PASS: dirname-handles-multiple-slashes
PASS: dirname-handles-relative-path
PASS: dirname-handles-root
PASS: dirname-handles-single-component
PASS: dirname-works
PASS: du-h-works
PASS: du-k-works
PASS: du-l-works
PASS: du-m-works
PASS: du-s-works
PASS: du-works
PASS: echo-does-not-print-newline
PASS: echo-prints-argument
PASS: echo-prints-arguments
SKIP: echo-prints-dash
PASS: echo-prints-newline
SKIP: echo-prints-non-opts
SKIP: echo-prints-slash-zero
SKIP: echo-prints-slash_00041
SKIP: echo-prints-slash_0041
SKIP: echo-prints-slash_041
SKIP: echo-prints-slash_41
PASS: expr-big
PASS: expr-works
PASS: false-is-silent
PASS: false-returns-failure
PASS: find-supports-minus-xdev
======================
echo -ne '' >input
echo -ne '' | cd find.tempdir && find -type f 2>&1
PASS: find -type f
======================
echo -ne '' >input
echo -ne '' | cd find.tempdir && find testfile -exec true {} \; 2>&1; echo $?
PASS: find -exec exitcode 1
======================
echo -ne '' >input
echo -ne '' | cd find.tempdir && find testfile -exec true {} + 2>&1; echo $?
PASS: find -exec exitcode 2
======================
echo -ne '' >input
echo -ne '' | cd find.tempdir && find testfile -exec false {} \; 2>&1; echo $?
PASS: find -exec exitcode 3
======================
echo -ne '' >input
echo -ne '' | cd find.tempdir && find testfile -exec false {} + 2>&1; echo $?
PASS: find -exec exitcode 4
======================
echo -ne '' >input
echo -ne '' | find / -maxdepth 0 -name /
PASS: find / -maxdepth 0 -name /
======================
echo -ne '' >input
echo -ne '' | find // -maxdepth 0 -name /
PASS: find // -maxdepth 0 -name /
======================
echo -ne '' >input
echo -ne '' | find / -maxdepth 0 -name //
PASS: find / -maxdepth 0 -name //
======================
echo -ne '' >input
echo -ne '' | find // -maxdepth 0 -name //
PASS: find // -maxdepth 0 -name //
======================
echo -ne '' >input
echo -ne '' | find ./// -name .
PASS: find ./// -name .
======================
echo -ne '' >input
echo -ne '' | find ./// -name .///
PASS: find ./// -name .///
======================
echo -ne '' >input
echo -ne '' | grep nonexistent 2> /dev/null ; echo $?
PASS: grep (exit with error)
======================
echo -ne '' >input
echo -ne '' | grep grep '/usr/lib/busybox/ptest/testsuite/grep.tests' > /dev/null 2>&1 ; echo $?
PASS: grep (exit success)
======================
echo -ne '' >input
echo -ne 'one\ntwo\nthree\nthree\nthree\n' | grep two
PASS: grep (default to stdin)
======================
echo -ne '' >input
echo -ne 'one\ntwo\nthree\nthree\nthree\n' | grep two -
PASS: grep - (specify stdin)
======================
echo -ne 'one\ntwo\nthree\nthree\nthree\n' >input
echo -ne '' | grep two input
PASS: grep input (specify file)
======================
echo -ne 'bug' >input
echo -ne '' | grep bug input
PASS: grep (no newline at EOL)
======================
echo -ne 'one\ntwo\nthree\nthree\nthree\n' >input
echo -ne '' | grep two input empty 2>/dev/null
PASS: grep two files
======================
echo -ne 'one\ntwo\nthree\n' >input
echo -ne 'one\ntwo\ntoo\nthree\nthree\n' | grep two - input
PASS: grep - infile (specify stdin and file)
======================
echo -ne '' >input
echo -ne 'one\ntwo\ntwo\nthree\nthree\nthree\n' | grep two - nonexistent 2> /dev/null ; echo $?
PASS: grep - nofile (specify stdin and nonexisting file)
======================
echo -ne '' >input
echo -ne 'one\ntwo\ntwo\nthree\nthree\nthree\n' | grep -q nomatch - nonexistent 2> /dev/null ; echo $?
PASS: grep -q - nofile (specify stdin and nonexisting file, no match)
======================
echo -ne '' >input
echo -ne 'one\ntwo\ntwo\nthree\nthree\nthree\n' | grep -q two - nonexistent ; echo $?
PASS: grep -q - nofile (specify stdin and nonexisting file, match)
======================
echo -ne '' >input
echo -ne '' | grep -s nomatch nonexistent ; echo $?
PASS: grep -s nofile (nonexisting file, no match)
======================
echo -ne '' >input
echo -ne 'nomatch\ndomatch\nend\n' | grep -s domatch nonexistent - ; echo $?
PASS: grep -s nofile - (stdin and nonexisting file, match)
SKIP: grep handles NUL in files
SKIP: grep handles NUL on stdin
SKIP: grep matches NUL
======================
echo -ne 'one\ntwo\n' >input
echo -ne '' | grep -e one -e two input ; echo $?
PASS: grep handles multiple regexps
======================
echo -ne 'one\ntwo\n' >input
echo -ne '' | grep -F -e one -e two input ; echo $?
PASS: grep -F handles multiple expessions
======================
echo -ne 'FOO\n' >input
echo -ne '' | grep -F -i foo input ; echo $?
PASS: grep -F handles -i
======================
echo -ne 'tw\ntwo\nthree\n' >input
echo -ne 'tw.\nthr\n' | grep -f - input ; echo $?
PASS: grep can read regexps from stdin
======================
echo -ne 'foo\n' >input
echo -ne '' | grep -x foo input ; echo $?
PASS: grep -x (full match)
======================
echo -ne 'foo bar\n' >input
echo -ne '' | grep -x foo input ; echo $?
PASS: grep -x (partial match 1)
======================
echo -ne 'bar foo\n' >input
echo -ne '' | grep -x foo input ; echo $?
PASS: grep -x (partial match 2)
======================
echo -ne 'foo\n' >input
echo -ne '' | grep -x -F foo input ; echo $?
PASS: grep -x -F (full match)
======================
echo -ne 'foo bar\n' >input
echo -ne '' | grep -x -F foo input ; echo $?
PASS: grep -x -F (partial match 1)
======================
echo -ne 'bar foo\n' >input
echo -ne '' | grep -x -F foo input ; echo $?
PASS: grep -x -F (partial match 2)
======================
echo -ne '' >input
echo -ne 'b\ar\nfoo\nbaz' | grep -E fo+
PASS: grep -E supports extended regexps
======================
echo -ne '' >input
echo -ne 'foo\nbar\n' | egrep foo
PASS: grep is also egrep
======================
echo -ne '' >input
echo -ne 'FOO\n' | egrep foo ; [ $? -ne 0 ] && echo yes
PASS: egrep is not case insensitive
======================
echo -ne '' >input
echo -ne '00:19:3E:00:AA:5E 00:1D:60:3D:3A:FB 00:22:43:49:FB:AA\n' | grep -E -o '([[:xdigit:]]{2}[:-]){5}[[:xdigit:]]{2}'
PASS: grep -E -o prints all matches
======================
echo -ne '' >input
echo -ne '/var/test\n' | grep -o "[^/]*$"
PASS: grep -o does not loop forever
======================
echo -ne '' >input
echo -ne 'test\n' | grep -o "" | head -n1
PASS: grep -o does not loop forever on zero-length match
======================
echo -ne '' >input
echo -ne 'test\n' | grep -f input
PASS: grep -f EMPTY_FILE
======================
echo -ne '' >input
echo -ne 'test\n' | grep -v -f input
PASS: grep -v -f EMPTY_FILE
======================
echo -ne 'foop\n' >input
echo -ne '' | grep -Fw foo input
PASS: grep -Fw matches only words
======================
echo -ne 'foop foo\n' >input
echo -ne '' | grep -Fw foo input
PASS: grep -Fw doesn't stop on 1st mismatch
======================
echo -ne 'foop foo\n' >input
echo -ne '' | grep -w foo input
PASS: grep -w doesn't stop on 1st mismatch
======================
echo -ne 'strstr\n' >input
echo -ne '' | grep -w ^str input
PASS: grep -w ^str doesn't match str not at the beginning
======================
echo -ne 'anything\n' >input
echo -ne '' | grep -w ^ input
PASS: grep -w ^ doesn't hang
======================
echo -ne 'wordword\n' >input
echo -ne '' | grep -w word input
PASS: grep -w word doesn't match wordword
======================
echo -ne 'ww\n' >input
echo -ne '' | grep -F -w w input
PASS: grep -F -w w doesn't match ww
======================
echo -ne 'bword,word\nwordb,word\nbwordb,word\n' >input
echo -ne '' | grep -w word input
PASS: grep -w word match second word
======================
echo -ne '' >input
echo -ne '  aa bb cc\n' | grep -x -v -e '.*aa.*' -e 'bb.*'; echo $?
PASS: grep -x -v -e EXP1 -e EXP2 finds nothing if either EXP matches
======================
echo -ne '' >input
echo -ne '' | grep -r . grep.testdir/symfoo
PASS: grep -r on symlink to dir
======================
echo -ne '' >input
echo -ne '' | grep -r . grep.testdir
PASS: grep -r on dir/symlink to dir
PASS: gunzip-reads-from-standard-input
PASS: gunzip: doesnt exist
PASS: gunzip: unknown suffix
PASS: gunzip: already exists
PASS: gunzip: stream unpack
PASS: gunzip: delete src
PASS: gzip-accepts-multiple-files
PASS: gzip-accepts-single-minus
SKIP: gzip-compression-levels
PASS: gzip-removes-original-file
======================
echo -ne '' >input
echo -ne '' | head head.input
PASS: head (without args)
======================
echo -ne '' >input
echo -ne '' | head -n 2 head.input
PASS: head -n <positive number>
SKIP: head -n <negative number>
======================
echo -ne '' >input
echo -ne '\0\0\0\0' | hexdump -C
PASS: hexdump -C with four NULs
PASS: hostname-d-works
PASS: hostname-i-works
PASS: hostname-s-works
PASS: hostname-works
PASS: id-g-works
PASS: id-u-works
PASS: id-un-works
PASS: id-ur-works
PASS: ln-creates-hard-links
PASS: ln-creates-soft-links
PASS: ln-force-creates-hard-links
PASS: ln-force-creates-soft-links
PASS: ln-preserves-hard-links
PASS: ln-preserves-soft-links
PASS: ls-1-works
PASS: ls-h-works
PASS: ls-l-works
PASS: ls-s-works
======================
echo -ne '' >input
echo -ne '' | touch ls.testdir/A ls.testdir/B; ln -s ls.testdir ls.link; ls ls.link; ls -1 ls.link/; ls -1 ls.link; rm -f ls.link
PASS: ls symlink_to_dir
PASS: md5sum-verifies-non-binary-file
SKIP: md5sum
SKIP: mdev add /block/sda
SKIP: mdev deletes /block/sda
SKIP: mdev stops on first rule
SKIP: mdev does not stop on dash-rule
SKIP: mdev $ENVVAR=regex match
SKIP: mdev move/symlink rule '>bar/baz'
SKIP: mdev move/symlink rule '>bar/'
SKIP: mdev move rule '=bar/baz/fname'
SKIP: mdev regexp substring match + replace
SKIP: mdev command
SKIP: mdev move and command
SKIP: mdev #maj,min and no explicit uid
SKIP: move rule does not delete node with name == device_name
PASS: mkdir-makes-a-directory
PASS: mkdir-makes-parent-directories
SKIP: mount
PASS: mv-files-to-dir
PASS: mv-follows-links
PASS: mv-moves-empty-file
PASS: mv-moves-file
PASS: mv-moves-hardlinks
PASS: mv-moves-large-file
PASS: mv-moves-small-file
PASS: mv-moves-symlinks
PASS: mv-moves-unreadable-files
SKIP: mv-preserves-hard-links
PASS: mv-preserves-links
PASS: mv-refuses-mv-dir-to-subdir
PASS: mv-removes-source-file
SKIP: od -b
SKIP: od -f
SKIP: od -b --traditional
SKIP: od -b --traditional FILE
======================
echo -ne 'qwe
zxc
' >input
echo -ne '--- input	Jan 01 01:01:01 2000
+++ input	Jan 01 01:01:01 2000
@@ -1,2 +1,3 @@
 qwe
+asd
 zxc
' | patch 2>&1; echo $?; cat input
PASS: patch with old_file == new_file
======================
echo -ne 'qwe
zxc
' >input
echo -ne '--- input.doesnt_exist	Jan 01 01:01:01 2000
+++ input	Jan 01 01:01:01 2000
@@ -1,2 +1,3 @@
 qwe
+asd
 zxc
' | patch 2>&1; echo $?; cat input
PASS: patch with nonexistent old_file
======================
echo -ne 'qwe
asd
zxc
' >input
echo -ne '--- input.doesnt_exist	Jan 01 01:01:01 2000
+++ input	Jan 01 01:01:01 2000
@@ -1,2 +1,3 @@
 qwe
+asd
 zxc
' | patch -R 2>&1; echo $?; cat input
PASS: patch -R with nonexistent old_file
======================
echo -ne 'abc
def
123
' >input
echo -ne '--- input.old	Jan 01 01:01:01 2000
+++ input	Jan 01 01:01:01 2000
@@ -1,2 +1,3 @@
 abc
+def
 123
' | patch 2>&1; echo $?; cat input
PASS: patch detects already applied hunk
======================
echo -ne 'abc
123
456
' >input
echo -ne '--- input.old	Jan 01 01:01:01 2000
+++ input	Jan 01 01:01:01 2000
@@ -1,2 +1,3 @@
 abc
 123
+456
' | patch 2>&1; echo $?; cat input
PASS: patch detects already applied hunk at the EOF
======================
echo -ne 'abc
def
123
' >input
echo -ne '--- input
+++ input
@@ -1,2 +1,3 @@
 abc
+def
 123
' | patch -N 2>&1; echo $?; cat input
PASS: patch -N ignores already applied hunk
======================
echo -ne 'abc
123
' >input
echo -ne '--- foo.old
+++ foo
@@ -1,2 +1,3 @@
 abc
+def
 123
' | cat >a.patch; patch input a.patch 2>&1; echo $?; cat input; rm a.patch
PASS: patch FILE PATCH
======================
echo -ne '111
222
333
444
555
666
777
888
999
' >input
echo -ne '--- input
+++ input
@@ -1,6 +1,4 @@
-111
-222
-333
+111changed
 444
 555
 666
' | patch 2>&1; cat input
PASS: patch at the beginning
======================
echo -ne '' >input
echo -ne '--- /dev/null
+++ testfile
@@ -0,0 +1 @@
+qwerty
' | patch 2>&1; echo $?; cat testfile; rm testfile
PASS: patch creates new file
======================
echo -ne '' >input
echo -ne '--- bogus_dir///dir2///file
+++ bogus_dir///dir2///file
@@ -1,2 +1,3 @@
 qwe
+asd
 zxc
' | patch -p1 2>&1; echo $?
PASS: patch understands ...dir///dir...
======================
echo -ne 'foo







bar
' >input
echo -ne '--- a/input.orig
+++ b/input
@@ -5,5 +5,8 @@ foo
 
 
 
+1
+2
+3
 
 bar
-- 
2.9.2
' | patch -p1 2>&1; echo $?; cat input
PASS: patch internal buffering bug?
======================
echo -ne '' >input
echo -ne '' | pidof veryunlikelyoccuringbinaryname ; echo $?
PASS: pidof (exit with error)
======================
echo -ne '' >input
echo -ne '' | pidof pidof > /dev/null; echo $?
PASS: pidof (exit with success)
======================
echo -ne '' >input
echo -ne '' | pidof pidof.tests | grep -o -w 3722
PASS: pidof this
SKIP: pidof -s
SKIP: pidof -o %PPID NOP
SKIP: pidof -o init
======================
echo -ne '' >input
echo -ne '' | busybox printf '\c' foo
PASS: printf produces no further output 1
======================
echo -ne '' >input
echo -ne '' | busybox printf '%s\c' foo bar
PASS: printf produces no further output 2
======================
echo -ne '' >input
echo -ne '' | busybox printf '%s\n' foo '/home/root'
PASS: printf repeatedly uses pattern for each argv
======================
echo -ne '' >input
echo -ne '' | busybox printf '%b' 'a\tb' 'c\d\n' 2>&1; echo $?
PASS: printf understands %b escaped_string
======================
echo -ne '' >input
echo -ne '' | busybox printf '%d\n' '"x' "'y" "'zTAIL" 2>&1; echo $?
PASS: printf understands %d '"x' "'y" "'zTAIL"
======================
echo -ne '' >input
echo -ne '' | busybox printf '%s\n' '"x' "'y" "'zTAIL" 2>&1; echo $?
PASS: printf understands %s '"x' "'y" "'zTAIL"
======================
echo -ne '' >input
echo -ne '' | busybox printf '|%23.12f|\n' 5.25 2>&1; echo $?
PASS: printf understands %23.12f
======================
echo -ne '' >input
echo -ne '' | busybox printf '|%*.*f|\n' 23 12 5.25 2>&1; echo $?
PASS: printf understands %*.*f
======================
echo -ne '' >input
echo -ne '' | busybox printf '|%*f|\n' -23 5.25 2>&1; echo $?
PASS: printf understands %*f with negative width
======================
echo -ne '' >input
echo -ne '' | busybox printf '|%.*f|\n' -12 5.25 2>&1; echo $?
PASS: printf understands %.*f with negative precision
======================
echo -ne '' >input
echo -ne '' | busybox printf '|%*.*f|\n' -23 -12 5.25 2>&1; echo $?
PASS: printf understands %*.*f with negative width/precision
======================
echo -ne '' >input
echo -ne '' | busybox printf '%zd\n' -5 2>&1; echo $?
PASS: printf understands %zd
======================
echo -ne '' >input
echo -ne '' | busybox printf '%ld\n' -5 2>&1; echo $?
PASS: printf understands %ld
======================
echo -ne '' >input
echo -ne '' | busybox printf '%Ld\n' -5 2>&1; echo $?
PASS: printf understands %Ld
======================
echo -ne '' >input
echo -ne '' | busybox printf '%d\n' 3 +3 '   3' '   +3' 2>&1; echo $?
PASS: printf handles positive numbers for %d
======================
echo -ne '' >input
echo -ne '' | busybox printf '%i\n' 3 +3 '   3' '   +3' 2>&1; echo $?
PASS: printf handles positive numbers for %i
======================
echo -ne '' >input
echo -ne '' | busybox printf '%x\n' 42 +42 '   42' '   +42' 2>&1; echo $?
PASS: printf handles positive numbers for %x
======================
echo -ne '' >input
echo -ne '' | busybox printf '%0.3f\n' .42 +.42 '   .42' '   +.42' 2>&1; echo $?
PASS: printf handles positive numbers for %f
======================
echo -ne '' >input
echo -ne '' | busybox printf '%d\n' 1 - 2 bad 3 123bad 4 2>&1; echo $?
PASS: printf handles %d bad_input
======================
echo -ne '' >input
echo -ne '' | busybox printf '%' a b c 2>&1; echo $?
PASS: printf aborts on bare %
======================
echo -ne '' >input
echo -ne '' | busybox printf '%r' a b c 2>&1; echo $?
PASS: printf aborts on %r
PASS: pwd-prints-working-directory
======================
echo -ne '' >input
echo -ne '' | readlink ./readlink_testdir/testfile
PASS: readlink on a file
======================
echo -ne '' >input
echo -ne '' | readlink ./testlink
PASS: readlink on a link
======================
echo -ne '' >input
echo -ne '' | readlink -f ./readlink_testdir/testfile
PASS: readlink -f on a file
======================
echo -ne '' >input
echo -ne '' | readlink -f ./testlink
PASS: readlink -f on a link
======================
echo -ne '' >input
echo -ne '' | readlink -f ./readlink_testdir/readlink_testdir/testlink
PASS: readlink -f on an invalid link
======================
echo -ne '' >input
echo -ne '' | readlink -f readlink_testdir/../readlink_testdir/testfile
PASS: readlink -f on a weird dir
PASS: rm-removes-file
PASS: rmdir-removes-parent-directories
======================
echo -ne '' >input
echo -ne 'hello\n' | sed ""
PASS: sed no files (stdin)
======================
echo -ne '' >input
echo -ne 'hello\n' | sed "" -
PASS: sed explicit stdin
======================
echo -ne '' >input
echo -ne '\n' | sed -e 's/$/@/'
PASS: sed handles empty lines
======================
echo -ne '' >input
echo -ne 'hello' | sed "" - -
PASS: sed stdin twice
======================
echo -ne '' >input
echo -ne '' | sed -e '1 d'
PASS: sed accepts blanks before command
======================
echo -ne '' >input
echo -ne '2\n' | sed -e 'i1
a3'
PASS: sed accepts newlines in -e
======================
echo -ne '' >input
echo -ne '2\n' | sed -e 'i\' -e '1' -e 'a\' -e '3'
PASS: sed accepts multiple -e
======================
echo -ne '' >input
echo -ne 'foo\n' | sed -n -e s/foo/bar/ -e s/bar/baz/
PASS: sed -n
======================
echo -ne '' >input
echo -ne 'string\n' | sed 's/z*//g'
PASS: sed with empty match
======================
echo -ne '' >input
echo -ne 'foo\n' | sed -e s/foo/bar/p -e s/bar/baz/p
PASS: sed s//p
======================
echo -ne '' >input
echo -ne 'abc\n' | sed -ne s/abc/def/p
PASS: sed -n s//p
======================
echo -ne '' >input
echo -ne '12345\n' | sed -e 's/[[:space:]]*/,/g'
PASS: sed s//g (exhaustive)
======================
echo -ne '' >input
echo -ne 'woo\n' | sed -e 's woo boing '
PASS: sed s arbitrary delimiter
======================
echo -ne '' >input
echo -ne 'foo\n' | sed -e s/foo/bar/ -e s/bar/baz/
PASS: sed s chains
======================
echo -ne '' >input
echo -ne 'foo\n' | sed -e s/foo/bar/ -e s/baz/nee/
PASS: sed s chains2
======================
echo -ne '' >input
echo -ne 'one@two' | sed -e 's@[@]@@'
PASS: sed s [delimiter]
======================
echo -ne '' >input
echo -ne 'one\ttwo' | sed 's/\t/ /'
PASS: sed s with \t (GNU ext)
======================
echo -ne '' >input
echo -ne 'foo\n' | sed -e 'b one;p;: one'
PASS: sed b (branch)
======================
echo -ne '' >input
echo -ne 'foo\n' | sed -e 'b;p'
PASS: sed b (branch with no label jumps to end)
======================
echo -ne '' >input
echo -ne 'a\nb\nc\n' | sed -e 's/a/1/;t one;p;: one;p'
PASS: sed t (test/branch)
======================
echo -ne '' >input
echo -ne 'a\nb\nc\n' | sed -e 's/a/b/;:loop;t loop'
PASS: sed t (test/branch clears test bit)
======================
echo -ne '' >input
echo -ne 'a\nb\nc\n' | sed -e 's/a/1/;T notone;p;: notone;p'
PASS: sed T (!test/branch)
======================
echo -ne '' >input
echo -ne 'a\nb\nc\n' | sed -e 'n;p'
PASS: sed n (flushes pattern space, terminates early)
======================
echo -ne '' >input
echo -ne 'a\nb\nc\n' | sed -e 'N;p'
PASS: sed N (flushes pattern space (GNU behavior))
======================
echo -ne '' >input
echo -ne 'a\nb\nc\n' | sed ':a;N;s/\n/ /;ta'
PASS: sed N test2
======================
echo -ne '' >input
echo -ne 'a\nb\nc\n' | sed 'N;s/\n/ /'
PASS: sed N test3
======================
echo -ne '' >input
echo -ne 'a\nb\nc\nd\n' | sed "/b/N;/b\\nc/i woo"
PASS: sed address match newline
======================
echo -ne '' >input
echo -ne 'a\nb\nc\n' | sed -n 'N;P;p'
PASS: sed N (stops at end of input) and P (prints to first newline only)
======================
echo -ne '' >input
echo -ne 'a\nb\nc\n' | sed G
PASS: sed G (append hold space to pattern space)
======================
echo -ne '' >input
echo -ne 'ook\n' | sed -e '/ook/d;s/ook/ping/p;i woot'
PASS: sed d ends script iteration
======================
echo -ne '' >input
echo -ne 'ook\nwoot\n' | sed -e '/ook/d;a\' -e 'bang'
PASS: sed d ends script iteration (2)
======================
echo -ne '' >input
echo -ne 'woo\0woo\0' | sed -e 's/woo/bang/g'
PASS: sed embedded NUL g
======================
echo -ne 'woo\n' >input
echo -ne 'woo\n' | sed -e 's/woo/bang/' input -
PASS: sed normal newlines
======================
echo -ne 'woo\n' >input
echo -ne 'woo' | sed -e 's/woo/bang/' input -
PASS: sed leave off trailing newline
======================
echo -ne 'woo' >input
echo -ne 'woo' | sed -e 's/woo/bang/' input -
PASS: sed autoinsert newline
======================
echo -ne '' >input
echo -ne 'one\ntwo' | sed -e 's/nohit//' input -
PASS: sed empty file plus cat
======================
echo -ne 'one\ntwo' >input
echo -ne '' | sed -e 's/nohit//' input -
PASS: sed cat plus empty file
======================
echo -ne '' >input
echo -ne 'woot' | sed -e '/woot/a woo' -
PASS: sed append autoinserts newline
======================
echo -ne 'boot' >input
echo -ne 'woot' | sed -e '/oot/a woo' - input
PASS: sed append autoinserts newline 2
======================
echo -ne 'boot' >input
echo -ne '' | sed -e '/oot/a woo' -i input && cat input
PASS: sed append autoinserts newline 3
======================
echo -ne '' >input
echo -ne 'woot' | sed -e '/woot/i woo' -
PASS: sed insert doesn't autoinsert newline
======================
echo -ne '' >input
echo -ne 'one' | sed -e 'p' -
PASS: sed print autoinsert newlines
======================
echo -ne 'one' >input
echo -ne 'two' | sed -e 'p' input -
PASS: sed print autoinsert newlines two files
======================
echo -ne 'no\n' >input
echo -ne '' | sed -ne 's/woo/bang/' input
PASS: sed noprint, no match, no newline
======================
echo -ne 'a woo\nb no' >input
echo -ne 'c woo\nd no' | sed -ne 's/woo/bang/p' input -
PASS: sed selective matches with one nl
======================
echo -ne 'a woo\nb woo' >input
echo -ne 'c no\nd woo' | sed -ne 's/woo/bang/p' input -
PASS: sed selective matches insert newline
======================
echo -ne 'a woo\nb woo' >input
echo -ne 'c no\nd no' | sed -ne 's/woo/bang/p' input -
PASS: sed selective matches noinsert newline
======================
echo -ne 'one' >input
echo -ne 'two' | sed -e '/one/a 111' -e '/two/i 222' -e p input -
PASS: sed clusternewline
======================
echo -ne 'thingy' >input
echo -ne 'again' | sed -e 's/i/z/' -e 'woutputw' input -; echo -n X; cat outputw
PASS: sed subst+write
======================
echo -ne 'a\0b\0' >input
echo -ne 'c' | sed 's/i/z/' input -
PASS: sed trailing NUL
======================
echo -ne 'a' >input
echo -ne '' | sed 's/a/z\
z/' input
PASS: sed escaped newline in command
======================
echo -ne '' >input
echo -ne 'hello\nthere' | sed -e '$p'
PASS: sed match EOF
======================
echo -ne 'one\ntwo' >input
echo -ne 'three\nfour' | sed -e '$p' input -
PASS: sed match EOF two files
======================
echo -ne 'one\ntwo' >input
echo -ne '' | sed -e '$i ook' -i input input2 && cat input input2
PASS: sed match EOF inline
======================
echo -ne '' >input
echo -ne '' | sed --version | grep -o 'GNU sed version '
PASS: sed lie-to-autoconf
======================
echo -ne '' >input
echo -ne 'woot' | sed -e '/woot/s//eep \0 eep/'
PASS: sed backref from empty s uses range regex
======================
echo -ne '' >input
echo -ne 'woot\n' | sed -e '/woot/s//eep \0 eep/'
PASS: sed backref from empty s uses range regex with newline
======================
echo -ne '' >input
echo -ne '' | sed -e '' -i 2> /dev/null || echo yes
PASS: sed -i with no arg [GNUFAIL]
======================
echo -ne '' >input
echo -ne 'xxx\n' | sed -e 's/xxx/[/'
PASS: sed s/xxx/[/
======================
echo -ne '' >input
echo -ne '0\n1\n2\n3\n' | sed 's/1/x/;T;n;: next;s/3/y/;t quit;n;b next;: quit;q'
PASS: sed n command must reset 'substituted' bit
======================
echo -ne '' >input
echo -ne 'first\nsecond\nthird\nfourth\n' | sed -n '1d;1,3p'
PASS: sed d does not break n,m matching
======================
echo -ne '' >input
echo -ne 'first\nsecond\nthird\nfourth\n' | sed -n '1d;1,/hir/p'
PASS: sed d does not break n,regex matching
======================
echo -ne '' >input
echo -ne 'first\nsecond\nthird\nfourth\nfirst2\nsecond2\nthird2\nfourth2\n' | sed -n '1,5d;1,/hir/p'
PASS: sed d does not break n,regex matching #2
======================
echo -ne '' >input
echo -ne 'first\nsecond\nthird\nfourth\n' | sed -n '2d;2,1p'
PASS: sed 2d;2,1p (gnu compat)
======================
echo -ne '' >input
echo -ne '/usr/lib\n' | sed 's,\(^/\|\)[^/][^/]*,>\0<,g'
PASS: sed beginning (^) matches only once
======================
echo -ne '' >input
echo -ne 'first\nsecond\n' | sed 'crepl'
PASS: sed c
======================
echo -ne '' >input
echo -ne 'qwe\nasd\nzxc\n' | sed '/asd/ { p; /s/ { s/s/c/ }; p; q }'
PASS: sed nested {}s
======================
echo -ne '' >input
echo -ne '	| one \\
	| two \\
' | sed -e '/| one /a \
	| three \\' -e '/| one-/a \
	| three-* \\'
PASS: sed a cmd ended by double backslash
======================
echo -ne '' >input
echo -ne 'line1\n' | sed '/1/a\\t\rzero\none\\ntwo\\\nthree'
PASS: sed a cmd understands \n,\t,\r
======================
echo -ne '' >input
echo -ne 'line1\n' | sed '/1/i\\t\rzero\none\\ntwo\\\nthree'
PASS: sed i cmd understands \n,\t,\r
======================
echo -ne '' >input
echo -ne '1\n2\n3\n4\n' | sed -n '1{N;N;d};1p;2,3p;3p;4p'
PASS: sed with N skipping lines past ranges on next cmds
======================
echo -ne 'foo\n' >input
echo -ne '' | cp input input2; sed -i -e '1s/foo/bar/' input input2 && cat input input2; rm input2
PASS: sed -i with address modifies all files, not only first
======================
echo -ne '' >input
echo -ne 'rrr\n' | sed 's/r/\r/'
PASS: sed understands \r
======================
echo -ne '1\n2\n3\n4\n' >input
echo -ne '' | sed '1,2d' -i input; echo $?; cat input
PASS: sed -i finishes ranges correctly
======================
echo -ne '' >input
echo -ne 'helllo\n' | sed 's/l*/@/g'
PASS: sed zero chars match/replace advances correctly 1
======================
echo -ne '' >input
echo -ne ' a.b\n' | sed 's [^ .]* x g'
PASS: sed zero chars match/replace advances correctly 2
======================
echo -ne '' >input
echo -ne '_aaa1aa\n' | sed 's/a/A/g'
PASS: sed zero chars match/replace logic must not falsely trigger here 1
======================
echo -ne '' >input
echo -ne 'qwerty\n' | sed 's/ *$/_/g'
PASS: sed zero chars match/replace logic must not falsely trigger here 2
======================
echo -ne '' >input
echo -ne 'this is a regular line
line with \
continuation
more regular lines
line with \
continuation
' | sed ': testcont; /\\$/{ =; N; b testcont }'
PASS: sed /$_in_regex/ should not match newlines, only end-of-line
======================
echo -ne '' >input
echo -ne 'aa\n' | sed -e 's/a/b/2; s/a/c/g'
PASS: sed s///NUM test
======================
echo -ne '' >input
echo -ne '1\n2\n3\n4\n5\n' | sed /^2/,2{d}
PASS: sed /regex/,N{...} addresses work
======================
echo -ne '' >input
echo -ne '1\n2\n3\n4\n5\n' | sed /^2/,+2{d}
PASS: sed /regex/,+N{...} addresses work
======================
echo -ne '1\n2\n3\n4\n5\n6\n7\n8\n' >input
echo -ne '1\n2\n4\n5\n6\n7\n8\n' | cat - >input2; sed /^4/,+2{d} -i input input2; echo $?; cat input input2; rm input2
PASS: sed /regex/,+N{...} -i works
======================
echo -ne '1\n2\n3\n4\n5\n6\n7\n8\n' >input
echo -ne '1\n2\n4\n5\n6\n7\n8\n' | cat - >input2; sed /^4/,+0{d} -i input input2; echo $?; cat input input2; rm input2
PASS: sed /regex/,+0{...} -i works
======================
echo -ne '1\n2\n3\n4\n5\n6\n7\n8\n' >input
echo -ne '1\n2\n4\n5\n6\n7\n8\n' | cat - >input2; sed /^4/,+0d -i input input2; echo $?; cat input input2; rm input2
PASS: sed /regex/,+0<cmd> -i works
======================
echo -ne '' >input
echo -ne '123\nqwe\nasd\n' | sed 's/qwe/ZZZ/wz'; cat z; rm z
PASS: sed 's///w FILE'
======================
echo -ne '' >input
echo -ne 'q\nw\ne\nr\n' | sed '/w/p;//q'
PASS: sed uses previous regexp
======================
echo -ne '' >input
echo -ne '' | seq 2> /dev/null || echo yes
PASS: seq (exit with error)
======================
echo -ne '' >input
echo -ne '' | seq 1 2 3 4 2> /dev/null || echo yes
PASS: seq (exit with error)
======================
echo -ne '' >input
echo -ne '' | seq 3
PASS: seq one argument
======================
echo -ne '' >input
echo -ne '' | seq 5 7
PASS: seq two arguments
======================
echo -ne '' >input
echo -ne '' | seq 7 5
PASS: seq two arguments reversed
======================
echo -ne '' >input
echo -ne '' | seq 3 3
PASS: seq two arguments equal
======================
echo -ne '' >input
echo -ne '' | seq 1 -15 1
PASS: seq two arguments equal, arbitrary negative step
======================
echo -ne '' >input
echo -ne '' | seq 1 +15 1
PASS: seq two arguments equal, arbitrary positive step
======================
echo -ne '' >input
echo -ne '' | seq 4 2 8
PASS: seq count up by 2
======================
echo -ne '' >input
echo -ne '' | seq 8 -2 4
PASS: seq count down by 2
======================
echo -ne '' >input
echo -ne '' | seq 4 -2 8
PASS: seq count wrong way #1
======================
echo -ne '' >input
echo -ne '' | seq 8 2 4
PASS: seq count wrong way #2
======================
echo -ne '' >input
echo -ne '' | seq 3 .3 4
PASS: seq count by .3
======================
echo -ne '' >input
echo -ne '' | seq 3 .30 4
PASS: seq count by .30
======================
echo -ne '' >input
echo -ne '' | seq 3 .30 4.000
PASS: seq count by .30 to 4.000
======================
echo -ne '' >input
echo -ne '' | seq .7 -.9 -2.2
PASS: seq count by -.9
======================
echo -ne '' >input
echo -ne '' | seq 4 0 8 | head -n 10
PASS: seq count by zero
======================
echo -ne '' >input
echo -ne '' | seq -w 003
PASS: seq one argument with padding
======================
echo -ne '' >input
echo -ne '' | seq -w 005 7
PASS: seq two arguments with padding
======================
echo -ne '' >input
echo -ne '' | seq -w 8 -3 04
PASS: seq count down by 3 with padding
======================
echo -ne '' >input
echo -ne '' | seq -w 09 .3 11
PASS: seq count by .3 with padding 1
======================
echo -ne '' >input
echo -ne '' | seq -w 03 .3 0004
PASS: seq count by .3 with padding 2
SKIP: sha1sum
SKIP: sha256sum
======================
echo -ne 'c\na\nb\n' >input
echo -ne '' | sort input
PASS: sort
======================
echo -ne '3\n1\n010\n' >input
echo -ne '' | sort input
PASS: sort #2
======================
echo -ne '' >input
echo -ne 'b\na\nc\n' | sort
PASS: sort stdin
======================
echo -ne '3\n1\n010\n' >input
echo -ne '' | sort -n input
PASS: sort numeric
======================
echo -ne 'point\nwook\npabst\naargh\nwalrus\n' >input
echo -ne '' | sort -r input
PASS: sort reverse
======================
echo -ne '42	1	3	woot
42	1	010	zoology
egg	1	2	papyrus
7	3	42	soup
999	3	0	algebra
' >input
echo -ne '' | sort -k4,4 input
PASS: sort one key
======================
echo -ne '42	1	3	woot
42	1	010	zoology
egg	1	2	papyrus
7	3	42	soup
999	3	0	algebra
' >input
echo -ne '' | sort -k2,3n input
PASS: sort key range with numeric option
======================
echo -ne '42	1	3	woot
42	1	010	zoology
egg	1	2	papyrus
7	3	42	soup
999	3	0	algebra
' >input
echo -ne '' | sort -k2,3n -r input
PASS: sort key range with numeric option and global reverse
======================
echo -ne '42	1	3	woot
42	1	010	zoology
egg	1	2	papyrus
7	3	42	soup
999	3	0	algebra
' >input
echo -ne '' | sort -k2,3rn input
PASS: sort key range with multiple options
======================
echo -ne 'c 3
b 2
d 2
' >input
echo -ne '' | sort -k 2,2n -k 1,1r input
PASS: sort key range with two -k options
======================
echo -ne '/a/2
/b/1
' >input
echo -ne '' | sort -n -k2 -t/ input
PASS: sort with non-default leading delim 1
======================
echo -ne '/b/1
/a/2
' >input
echo -ne '' | sort -n -k3 -t/ input
PASS: sort with non-default leading delim 2
======================
echo -ne '//a/2
//b/1
' >input
echo -ne '' | sort -n -k3 -t/ input
PASS: sort with non-default leading delim 3
======================
echo -ne 'a/a:a
a:b
' >input
echo -ne '' | sort -t: -k1,1 input
PASS: sort with non-default leading delim 4
======================
echo -ne 'aa.2
ab.1
' >input
echo -ne '' | sort -t. -k1,1.1 -k2 input
PASS: sort with ENDCHAR
======================
echo -ne 'GLIBC_2.21
GLIBC_2.1.1
GLIBC_2.2.1
GLIBC_2.2
GLIBC_2.20
GLIBC_2.10
GLIBC_2.1
' >input
echo -ne '' | sort -t. -k 1,1 -k 2n,2n -k 3 input
PASS: glibc build sort
======================
echo -ne 'GLIBC_2.10
GLIBC_2.2.1
GLIBC_2.1.1
GLIBC_2.20
GLIBC_2.2
GLIBC_2.1
GLIBC_2.21
' >input
echo -ne '' | sort -u -t. -k 1,1 -k 2n,2n -k 3 input
PASS: glibc build sort unique
======================
echo -ne 'a c
b c
' >input
echo -ne '' | sort -u -k2 input
PASS: sort -u should consider field only when discarding
======================
echo -ne 'one\0two\0three\0' >input
echo -ne '' | sort -z input
PASS: sort -z outputs NUL terminated lines
======================
echo -ne '' >input
echo -ne ' 2 \n 1 \n a \n' | sort -n -k2 -t ' '
PASS: sort key doesn't strip leading blanks, disables fallback global sort
======================
echo -ne '222
111
' >input
echo -ne '' | sort -o input input && cat input
PASS: sort file in place
======================
echo -ne '' >input
echo -ne '' | start-stop-daemon -S -x true 2>&1; echo $?
PASS: start-stop-daemon -x without -a
======================
echo -ne '' >input
echo -ne '' | start-stop-daemon -S -a false 2>&1; echo $?
PASS: start-stop-daemon -a without -x
PASS: strings-works-like-GNU
PASS: tail-n-works
SKIP: tail-works
======================
echo -ne '' >input
echo -ne 'qw' | tail -c +55 2>&1; echo $?
PASS: tail: +N with N > file length
======================
echo -ne '' >input
echo -ne '' | 
	dd if=/dev/zero bs=16k count=1 2>/dev/null | tail -c +8200 | wc -c;
	dd if=/dev/zero bs=16k count=1 2>/dev/null | tail -c +8208 | wc -c;
	
PASS: tail: -c +N with largish N
PASS: tar-archives-multiple-files
PASS: tar-complains-about-missing-file
PASS: tar-demands-at-least-one-ctx
PASS: tar-demands-at-most-one-ctx
PASS: tar-extracts-all-subdirs
PASS: tar-extracts-file
PASS: tar-extracts-from-standard-input
PASS: tar-extracts-multiple-files
PASS: tar-extracts-to-standard-output
PASS: tar-handles-cz-options
PASS: tar-handles-empty-include-and-non-empty-exclude-list
PASS: tar-handles-exclude-and-extract-lists
PASS: tar-handles-multiple-X-options
PASS: tar-handles-nested-exclude
SKIP: tar_with_link_with_size
SKIP: tar_with_prefix_fields
======================
echo -ne '' >input
echo -ne '' | \
tar xvf - 2>&1; echo $?

PASS: Empty file is not a tarball
======================
echo -ne '' >input
echo -ne '' | \
{ tar xvzf - 2>&1; echo $?; } | grep -Fv "invalid magic"

PASS: Empty file is not a tarball.tar.gz
======================
echo -ne '' >input
echo -ne '' | \
dd if=/dev/zero bs=512 count=2 2>/dev/null | tar xvf - 2>&1; echo $?

PASS: Two zeroed blocks is a ('truncated') empty tarball
======================
echo -ne '' >input
echo -ne '' | \
dd if=/dev/zero bs=512 count=20 2>/dev/null | tar xvf - 2>&1; echo $?

PASS: Twenty zeroed blocks is an empty tarball
======================
echo -ne '' >input
echo -ne '' | \
>input_hard1
ln input_hard1 input_hard2
mkdir input_dir
>input_dir/file
chmod -R 644 *
chmod    755 input_dir
tar cf test.tar input input_dir/ input_hard1 input_hard2 input_hard1 input_dir/ input
tar tvf test.tar | sed "s/.*[0-9] input/input/"
rm -rf input_dir
tar xf test.tar 2>&1
echo Ok: $?
ls -l . input_dir/* | grep input_ | sed "s/\\(^[^ ]*\\) .* input/\\1 input/"

PASS: tar hardlinks and repeated files
======================
echo -ne '' >input
echo -ne '' | \
>input_hard1
chmod 741 input_hard1
ln input_hard1 input_hard2
mkdir input_dir
ln input_hard1 input_dir
ln input_hard2 input_dir
chmod 550 input_dir
# On some filesystems, input_dir/input_hard2 is returned by readdir
# BEFORE input_dir/input_hard1! Thats why we cant just "tar cf ... input_*":
tar cf test.tar input_dir/input_hard* input_hard*
tar tvf test.tar | sed "s/.*[0-9] input/input/"
chmod 770 input_dir
rm -rf input_*
tar xf test.tar 2>&1
echo Ok: $?
ls -l . input_dir/* | grep "input.*hard" | sed "s/\\(^[^ ]*\\) .* input/\\1 input/"

PASS: tar hardlinks mode
======================
echo -ne '' >input
echo -ne '' | \
>input_file
chmod 741 input_file
ln -s input_file input_soft
mkdir input_dir
ln input_file input_dir
ln input_soft input_dir
chmod 550 input_dir
tar cf test.tar input_dir/* input_[fs]*
tar tvf test.tar | sed "s/.*[0-9] input/input/" | sort
chmod 770 input_dir
rm -rf input_*
tar xf test.tar 2>&1
echo Ok: $?
ls -l . input_dir/* | grep "input_[fs]" | sed "s/\\(^[^ ]*\\) .* input/\\1 input/"

PASS: tar symlinks mode
SKIP: tar --overwrite
======================
echo -ne '' >input
echo -ne '' | dd count=1 bs=1M if=/dev/zero of=F0 2>/dev/null
tar -czf F0.tgz F0
rm F0
tar -xzvf F0.tgz && echo Ok
rm F0 || echo BAD

PASS: tar extract tgz
SKIP: tar extract txz
======================
echo -ne '' >input
echo -ne '' | rm -rf input_* test.tar 2>/dev/null
mkdir input_dir
echo Ok >input_dir/file
tar cf test.tar ./../tar.tempdir/input_dir/../input_dir 2>&1
rm -rf input_* 2>/dev/null
tar -vxf test.tar 2>&1
cat input_dir/file 2>&1

PASS: tar strips /../ on extract
SKIP: tar does not extract into symlinks
SKIP: tar -k does not extract into symlinks
SKIP: Pax-encoded UTF8 names and symlinks
======================
echo -ne '' >input
echo -ne 'begin-base64 644 tar_symlink_attack.tar.bz2
QlpoOTFBWSZTWZgs7bQAALT/hMmQAFBAAf+AEMAGJPPv32AAAIAIMAC5thlR
omAjAmCMADQT1BqNE0AEwAAjAEwElTKeo9NTR6h6gaeoA0DQNLVdwZZ5iNTk
AQwCAV6S00QFJYhrlfFkVCEDEGtgNVqYrI0uK3ggnt30gqk4e1TTQm5QIAKa
SJqzRGSFLMmOloHSAcvLiFxxRiQtQZF+qPxbo173ZDISOAoNoPN4PQPhBhKS
n8fYaKlioCTzL2oXYczyUUIP4u5IpwoSEwWdtoA=
====
' | \
exec 2>&1
uudecode -o input && tar xvf input; echo $?
ls /tmp/bb_test_evilfile
ls bb_test_evilfile
ls symlink/bb_test_evilfile

FAIL: Symlink attack: create symlink and then write through it
--- expected
+++ actual
@@ -1,8 +1,5 @@
-anything.txt
-symlink
-symlink/bb_test_evilfile
-tar: can't create symlink 'symlink' to '/tmp'
-1
+./testing.sh: line 95: uudecode: command not found
+127
 ls: /tmp/bb_test_evilfile: No such file or directory
 ls: bb_test_evilfile: No such file or directory
-symlink/bb_test_evilfile
+ls: symlink/bb_test_evilfile: No such file or directory
======================
echo -ne '' >input
echo -ne '' | \
mkdir dir
>dir/a
ln -s ../dir/a dir/b
ln dir/b dir/c
mkdir new
tar cf - dir/* | tar -C new -xvf - 2>&1

PASS: Symlinks and hardlinks coexist
PASS: tee-appends-input
PASS: tee-tees-input
======================
echo -ne '' >input
echo -ne '' | busybox test; echo $?
PASS: test: should be false (1)
======================
echo -ne '' >input
echo -ne '' | busybox test ''; echo $?
PASS: test '': should be false (1)
======================
echo -ne '' >input
echo -ne '' | busybox test !; echo $?
PASS: test !: should be true (0)
======================
echo -ne '' >input
echo -ne '' | busybox test a; echo $?
PASS: test a: should be true (0)
======================
echo -ne '' >input
echo -ne '' | busybox test --help; echo $?
PASS: test --help: should be true (0)
======================
echo -ne '' >input
echo -ne '' | busybox test -f; echo $?
PASS: test -f: should be true (0)
======================
echo -ne '' >input
echo -ne '' | busybox test ! -f; echo $?
PASS: test ! -f: should be false (1)
======================
echo -ne '' >input
echo -ne '' | busybox test a = a; echo $?
PASS: test a = a: should be true (0)
======================
echo -ne '' >input
echo -ne '' | busybox test -lt = -gt; echo $?
PASS: test -lt = -gt: should be false (1)
======================
echo -ne '' >input
echo -ne '' | busybox test a -a !; echo $?
PASS: test a -a !: should be true (0)
======================
echo -ne '' >input
echo -ne '' | busybox test -f = a -o b; echo $?
PASS: test -f = a -o b: should be true (0)
======================
echo -ne '' >input
echo -ne '' | busybox test ! a = b -a ! c = c; echo $?
PASS: test ! a = b -a ! c = c: should be false (1)
======================
echo -ne '' >input
echo -ne '' | busybox test ! a = b -a ! c = d; echo $?
PASS: test ! a = b -a ! c = d: should be true (0)
======================
echo -ne '' >input
echo -ne '' | busybox test '!' = '!'; echo $?
PASS: test '!' = '!': should be true (0)
======================
echo -ne '' >input
echo -ne '' | busybox test '(' = '('; echo $?
PASS: test '(' = '(': should be true (0)
======================
echo -ne '' >input
echo -ne '' | busybox test '!' '!' = '!'; echo $?
PASS: test '!' '!' = '!': should be false (1)
======================
echo -ne '' >input
echo -ne '' | busybox test '!' '(' = '('; echo $?
PASS: test '!' '(' = '(': should be false (1)
PASS: touch-creates-file
PASS: touch-does-not-create-file
PASS: touch-touches-files-after-non-existent-file
PASS: tr-d-alnum-works
PASS: tr-d-works
PASS: tr-non-gnu
PASS: tr-rejects-wrong-class
PASS: tr-works
======================
echo -ne '' >input
echo -ne '[qwe]' | tr '[q-z]' '_Q-Z+'
PASS: tr does not treat [] in [a-z] as special
======================
echo -ne '' >input
echo -ne '19AFH\n' | tr -cd '[0-9A-F]'
PASS: tr understands 0-9A-F
======================
echo -ne '' >input
echo -ne '19AFH\n' | tr -cd '[:xdigit:]'
PASS: tr understands [:xdigit:]
======================
echo -ne '' >input
echo -ne '789abcxyz\n' | tr '[:digit:]y-z' 111111111123
PASS: tr does not stop after [:digit:]
======================
echo -ne '' >input
echo -ne '#0123456789ABCDEFGabcdefg\n' | tr '[:xdigit:]Gg' 1111111151242222333330xX
PASS: tr has correct xdigit sequence
PASS: true-is-silent
PASS: true-returns-success
======================
echo -ne '' >input
echo -ne '' | uniq nonexistent 2> /dev/null || echo yes
PASS: uniq (exit with error)
======================
echo -ne '' >input
echo -ne '' | uniq /dev/null && echo yes
PASS: uniq (exit success)
======================
echo -ne '' >input
echo -ne 'one\ntwo\ntwo\nthree\nthree\nthree\n' | uniq
PASS: uniq (default to stdin)
======================
echo -ne '' >input
echo -ne 'one\ntwo\ntwo\nthree\nthree\nthree\n' | uniq -
PASS: uniq - (specify stdin)
======================
echo -ne 'one\ntwo\ntwo\nthree\nthree\nthree\n' >input
echo -ne '' | uniq input
PASS: uniq input (specify file)
======================
echo -ne 'one\ntwo\ntwo\nthree\nthree\nthree\n' >input
echo -ne '' | uniq input actual > /dev/null
PASS: uniq input outfile (two files)
======================
echo -ne '' >input
echo -ne 'one\ntwo\ntwo\nthree\nthree\nthree\n' | uniq - actual
PASS: uniq (stdin) outfile
======================
echo -ne 'one\ntwo\ntwo\nthree\nthree\nthree\n' >input
echo -ne '' | uniq input -
PASS: uniq input - (specify stdout)
======================
echo -ne '' >input
echo -ne 'one\ntwo\ntwo\nthree\nthree\nthree\n' | uniq -c | sed 's/^[ \t]*//'
PASS: uniq -c (occurrence count)
======================
echo -ne '' >input
echo -ne 'one\ntwo\ntwo\nthree\nthree\nthree\n' | uniq -d
PASS: uniq -d (dups only)
======================
echo -ne '' >input
echo -ne 'cc	dd	ee8
bb	cc	dd8
aa	bb	cc9
' | uniq -f2 -s 3
PASS: uniq -f -s (skip fields and chars)
======================
echo -ne '' >input
echo -ne 'cc1
cc2
cc3
' | uniq -w 2
PASS: uniq -w (compare max characters)
======================
echo -ne '' >input
echo -ne 'aaccaa
aaccbb
bbccaa
' | uniq -s 2 -w 2
PASS: uniq -s -w (skip fields and compare max chars)
======================
echo -ne '' >input
echo -ne 'one\ntwo\ntwo\nthree\nthree\nthree\n' | uniq -d -u
PASS: uniq -u and -d produce no output
======================
echo -ne '' >input
echo -ne '' | unzip -q foo.zip foo/ && test -d foo && test ! -f foo/bar && echo yes
PASS: unzip (subdir only)
SKIP: unzip (bad archive)
SKIP: unzip (archive with corrupted lzma 1)
SKIP: unzip (archive with corrupted lzma 2)
PASS: uptime-works
PASS: wc-counts-all
PASS: wc-counts-characters
PASS: wc-counts-lines
PASS: wc-counts-words
PASS: wc-prints-longest-line-length
FAIL: wget--O-overrides--P
+ test x '!=' x
+ mkdir foo
+ busybox wget -q -O index.html -P foo http://www.google.com/
wget: bad address 'www.google.com'
FAIL: wget-handles-empty-path
+ test x '!=' x
+ busybox wget http://www.google.com
wget: bad address 'www.google.com'
FAIL: wget-retrieves-google-index
+ test x '!=' x
+ busybox wget -q -O foo http://www.google.com/
wget: bad address 'www.google.com'
FAIL: wget-supports--P
+ test x '!=' x
+ mkdir foo
+ busybox wget -q -P foo http://www.google.com/
wget: bad address 'www.google.com'
PASS: which-uses-default-path
SKIP: xargs-works
======================
echo -ne '' >input
echo -ne 'a\n_\nb\n' | xargs -E _
PASS: xargs -E _ stops on underscore
======================
echo -ne '' >input
echo -ne 'a\n_\nb\n' | xargs -E ''
PASS: xargs -E ''
======================
echo -ne '' >input
echo -ne 'a\n_\nb\n' | xargs -e
PASS: xargs -e without param
======================
echo -ne '' >input
echo -ne 'a\n_\nb\n' | xargs
PASS: xargs does not stop on underscore ('new' GNU behavior)
======================
echo -ne '' >input
echo -ne 'a\n' | xargs -s7 echo
PASS: xargs -s7 can take one-char input
======================
echo -ne '' >input
echo -ne '1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 00\n' | xargs -ts25 echo 2>&1 >/dev/null
PASS: xargs -sNUM test 1
======================
echo -ne '' >input
echo -ne '2 3 4 5 6 7 8 9 0 2 3 4 5 6 7 8 9 00\n' | xargs -ts25 echo 1 2>&1 >/dev/null
PASS: xargs -sNUM test 2
